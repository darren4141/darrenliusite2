<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project 7</title>
  <link rel="stylesheet" href="projectstylesheet.css">
</head>

<body>
  <div class="project-content">
    <a href="index.html" class="close-button">&times;</a>
    <div class="project-text">
      <h1>Mini Drone V2</h1>
      <h2 class="subtitle">2025 | In Progress</h2>
      <p>After some unsuccessful flight tests of my original drone, I realized I would have to make some modifications
        to be able to
        achieve flight.</p>

      <img src="project7/drone3d.png" alt="drone 3d model" , width="75%">

      <h2>Hardware</h2>
      <p>I started by designing a lower profile flight controller PCB which used the smaller ESP32-XIAO C6
        microcontroller.</p>
      <img src="project7/mini_pcb_render.jpg" alt="board render" , width="31%">
      <img src="project7/mini_fc_pcb_front.jpg" alt="mini-pcb-front" , width="30%">
      <img src="project7/mini_fc_pcb.jpg" alt="mini-pcb-back" , width="33%">
      <p>This low-profile PCB fits behind the footprint of an ESP32, featuring a built in IMU with I2C communication,
        four motor drivers, and status LEDs</p>

      <h2>Initial thrust:</h2>
      <p>The PCB allowed for a much smaller and more symmetrical footprint. Additionally, I switched to smaller
        propellers.</p>
      <img src="project7/dronev2.jpg" alt="dronev2" , width="38%">
      <img src="project7/flight.gif" alt="flight-gif" , width="55%">

      <h2>Firmware & Controls</h2>
      <p>The firmware for thes project uses the ESP-IDF framework and freeRTOS for task scheduling. Core tasks include
        flight control + PWM setting, IMU reading and parsing, and periodic debug log value output. A webserver running
        in the background enables real-time data logging and user input.</p>
      <h3>Highlights:</h3>
      <p>- The MPU6050 IMU driver uses I2C and implements sensor fusion, using gyroscope + accelerometer data, and a
        Mahony filter to compute stable pitch + roll estimates. Additionally, I added an auto calibration feature that
        sets new pitch/roll offsets for accurate zeroing.</p>
      <p>- Since I was now working in a multi-task, mixed frequency environment, traditional print debugging became
        messy. I implemented a global logging task that manages multiple data streams to display telemetry data at a
        consistent, organized rate.
      </p>
      <h3>Flight control algorithm:</h3>
      <img src="project7/flightcontrolflowchart.png" alt="flight controller flowchart" width="100%">
    </div>
  </div>
</body>

</html>